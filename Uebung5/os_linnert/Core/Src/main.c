/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stdint.h>
#include <stddef.h>
#include "stm32l4xx.h"

#include "uart.h"
#include "os.h"
#include "exception_handlers.h"
#include "syscalls.h"

#define REPEAT_BURSTS   40u     // how many bursts total (thread ends afterwards)
#define BURST_LEN       1u      // how many letters printed back-to-back per burst
#define PAUSE_LOOPS     2000u   // small pause between bursts (TUNE THIS)

static inline void busy_pause(unsigned loops) {
    for (volatile unsigned i = 0; i < loops; i++) {
        __NOP();
    }
}

static void worker_thread(void *arg) {
    char c = (char)(uintptr_t)arg;

    for (unsigned k = 0; k < REPEAT_BURSTS; k++) {
        for (unsigned j = 0; j < BURST_LEN; j++) {
            sys_putchar((int)c);
        }

        if (c >= 'A' && c <= 'Z') {
            // active wait for uppercase (old behavior)
            busy_pause(PAUSE_LOOPS);
        } else {
            // passive sleep via Syscall
            sys_sleep_ms(OS_TIME_SLICE_MS);
        }
    }

    sys_thread_exit();
}

int main(void) {
    uart2_init(115200);


    os_init();

    // create listener thread that blocks on sys_getchar()
    extern void listener_thread(void *arg);
    os_thread_create(listener_thread, NULL);

    systick_init();          // SysTick prints '!' and triggers PendSV
    uart2_enable_rx_irq();

    __enable_irq();

    uart_printf("Ready. Press keys...\n");
    os_start();              // never returns

    while (1) { }
}

// Listener thread: wartet blockierend auf Zeichen und erzeugt Worker-Threads
void listener_thread(void *arg) {
    (void)arg;
    for (;;) {
        int c = sys_getchar();
        if (c < 0) continue; // should not happen, but guard
        sys_thread_create(worker_thread, (void*)(uintptr_t)c);
    }
}
